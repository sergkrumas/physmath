

# README.md, 20 июня 2025, Sergei Krumas

# graph_algs.py, код портирован с Object Pascal (Delphi) на Python. Взято из книги «Занимательное программирование. Самоучитель» 2005, страницы 145 - 175
# (22 июн 25) Код дополнен окном для воспроизведения анимации последовательности ходов решения 

# НЕИНФОРМИРОВАННЫЕ МЕТОДЫ ПОИСКА - перебираем всё по очереди, пока не наткнёмся на то, что искали
- ПОИСК В ГЛУБИНУ (DEPTH-FIRST SEARCH) - анализируется первый по списку сосед текущей вершины, затем - его первый сосед и т.д. Если у некоторой вершины нет соседей, аналогичным образом анализируется второй сосед вершины, рассмотренной до неё. Таким образом, процедура поиска сразу же устремляется к вершинам, далёким от стартовой (то есть в глубину), и, лишь достигнув вершины, не имеющей соседей, возвращается назад. Главный плюс - малый расход памяти. Главный минус - при поиске в графе, содержащем цикл, процедура может зациклиться.
- ПОИСК В ШИРИНУ (BREADTH-FIRST SEARCH) - сначала анализируются все соседи текущей вершины. Затем - соседи соседей, соседи соседей соседей и т.д. Пока процедура не рассмотрит все вершины, находящиеся на расстоянии n рёбер от стартовой, перехода к более далёким вершинам, длина пути до которых (в рёбрах) равна n+1, не произойдёт. Эта процедура застрахована от зацикливания. Главный минус - солидные затраты памяти. На каждом шаге процедура сохраняет в списке все вершины, находящиеся на некоторой глубине от стартовой. Если граф, к примеру, имеет вид бинарного дерева, количество хранимых вершин растёт экспоненциально. Если нужен маршрут от стартовой вершины до целевой, то потребуется дополниительная память.
- ДВУНАПРАВЛЕННЫЙ ПОИСК (BIDIRECTIONAL SEARCH) - запускаем сразу две процедуры поиска в ширину. Одна начинает работу со стартовой вершины, другая - с целевой. Как только некоторая третья вершина оказывается в поле зрения каждой из этих процедур, можно строить маршрут. Процедуры работают по очереди - сделали один шаг в первой процедуре, передали управление второй и наоборот. Используя этот метод, можно получить решение быстрее и с меньшими затратами памяти по сравнению с простой процедурой поиска в ширину.




# ПСЕВДОКОДЫ

```
def DepthFirstSearch(v: Vertex, depth: int) -> bool:
    Path[depth] = v #записываем очередную вершину на пути к цели
    ЕСЛИ v - целавая вершина
        выход из процедуры с результатом True (цель найдена)

    ЦИКЛ по всем соседним вершинам
        vn = очередная соседняя вершина
        ЕСЛИ DepthFirstSearch(vn, depth+1) == True
            выход из процедуры с результатом true
    КОНЕЦ ЦИКЛА
    выход из процедуры с результатом False (цель не найдена)

```

при вызове функции DepthFirstSearch необходимо передать стартовую вершину и число 0
res = DepthFirstSearch(StartVertex, 0)
Если поиск закончился успешно, то путь от стартовой вершины до целевой хранится в массиве Path.



```
def BreadthFirstSearch(v: Vertex) -> bool:
    внести в список L (изначально пуст) вершину V
    ЦИКЛ
        v = первый элемент списка L
        удалить первый элемент списка L

        ЕСЛИ v - целевая вершина
            выход из процедуры с результатом True (цель найдена)

        добавить в хвост списка L всех соседей вершины v
    ПОКА список L непуст
    выход из процедуры с результатом False (цель не найдена)

```
Ключевой момент алгоритма - добавление новых элементов именно в хвост, а не в начало и не в середину списка L.





# ИНФОРМИРОВАННЫЕ МЕТОДЫ ПОИСКА
- ПРОЦЕДУРА A* - на каждом шаге можно контролировать процесс выбора следующей рассматриваемой вершины. Процедура применяется к взвешенным графам. В задаче о поиске маршрута на карте веса рёбер, очевидно, равны расстояниям между объектами, которым соответствуют вершины. В графе, соответствующем игре в 8, можно приписать любому ребру вес, равный единице. Тогда суммарная стоимость маршрута от стартовой вершины до целевой окажется равной количеству сделанных ходов. Если вообще не интересуют веса рёбер, а применить процедуру хочется, просто следует считать, что вес каждого ребра равен единице. Вершине сопоставляется два числа - ЦЕНА (cost) и ЭВРИСТИКА (heuristics). ЦЕНА это суммарный вес рёбер на пути от стартовой вершины до текущей. Под ценой понимается стоимость именно того маршрута, которым процедура следовала от стартовой вершины до текущей, никто не требует вычислять цену оптимального пути. ЭВРИСТИКА - это расчётная стоимость минимального пути от текущей вершины до целевой вершины. Точное значение этой величины мы, конечно, знать не можем, но сделать более-менее разумное предположение обычно в состоянии. Функция, сопоставляющая любой вершине графа некоторую эвристику, называется эвристической функцией (heuristic function). Эвристическая функция, прогнозы которой всегда точны или оптимистичны (то есть предсказываемое значение стоимости оптимального пути никогда не превосходит его реальной стоимости), называется допустимой (admissible). Использование только допустимых эвристических функций гарантирует: целевая вершина будет найдена, а используемый маршрут от стартовой вершины до неё - оптимальным. Простейшая допустимая эвристическая функция - сопоставление любой вершине графа нуля в качестве значения эвристики. Действительно, стоимость какого бы то ни было маршрута не может оказаться меньше нуля, но пользы от такой функции не будет - в действительности вы получите обыкновенный поиск в ширину. Выбор хорошей эвристической функции - настоящее искусство, сравнимое с выбором используемого в алгоритмах сжатия данных предиктора. ПРОЦЕДУРА A* НА КАЖДОМ ШАГЕ ВЫБИРАЕТ ИЗ СПИСКА L (L2 в коде ниже) ВЕРШИНУ, СУММА ЗНАЧЕНИЙ ЭВРИСТИКИ И ЦЕНЫ КОТОРОЙ МИНИМАЛЬНА.
- ПРОЦЕДУРА IDA* (Iterative Deepening A*) - Если бы для любой задачи можно было создать хорошую эвристическую функцию, процедура A* удовлетворила бы любого разработчика. К сожалению, не так уж редки случаи, когда не очень хорошая (хотя и допустимая) эвристическая функция уводит процедуру поиска куда-то в дебри графа, хотя решение находится где-то под самым носом. К примеру, прервав после десяти минут работы программу анализа шахматного этюда, вы с удивлением обнаруживаете, что она просматривает какую-то позицию в глубине в семь ходов от начальной: а вы-то ожидали что-то вроде мата в три хода. В подобных случаях применяют процедуру IDA*. Её суть состоит в последовательном применении алгоритма A* к графу задачи с постепенным снятием ограничений на глубину просмотра. Сначала процедуре A* разрешается искать лишь на единичной глубине (то есть среди непосредственных соседей стартовой вершины), затем, в случае неудачи, - на глубине, не превосходящей 2 (среди соседей стартовой вершины и их соседей) и т.д. Таким образом, каждый раз в случае неудачи процедура A* запускается заново, но при этом ей позволяется заглянуть глубже.


Из трёх описанных методов поиска для игры в 8 лучше всего, наверное, подходит двунаправленный поиск, поскольку мы знаем как стартовую, так и целевую вершины. Поиск в глубину не годится из-за цикличности графа задачи. Остановимся на поиске в ширину, чтобы не усложнять программу. Двунаправленный поиск ничего принципиально не даст, а листинг разрастётся вполне ощутимо.


В качестве эвристики выбирается количество кубиков, находящихся не на своих местах, такая функция будет допустимой. Если, к примеру, четыре кубика расположены неверно, то меньше чем за четыре хода получить желаемое расположение, очевидно, не удастся. 


# ПРОЕКТЫ ДЛЯ САМОСОВЕРШЕНСТВОВАНИЯ
- Сравнить поиск в глубину с рекурсивным обходом лабиринта. Лабиринт в общем случае является циклическим графом. Какой приём используется в рекурсивном обходе для предотвращения зацикливания?
- Сравние поиск в ширину с алгоритмом волновой трассировки
- Подсчитайте (хотя бы примерно), какой объём памяти потребуется для анализа графа игры в 8 на глубину в 10 ходов при использовании поиска в ширину.
- Напишите эвристическую функцию для задачи о поиске маршрута на карте




# (22 июн 25) graph_algs_maze.py, код портирован с Object Pascal (Delphi) на Python. Взято из книги «Занимательное программирование. Самоучитель» 2005, страницы 92 - 116

# РЕШЕНИЕ ЛАБИРИНТОВ

## РЕКУРСИВНЫЙ ОБХОД
Пузырьковая сортировка в мире алгоритмов для лабиринтов.
Достоинства:
- простой
Недостатки: 
- обходит лабиринт нерационально. Может пройти достаточное количество времени, прежде чем решение будет найдено. 
- полученное решение может не быть оптимальным. 
- третий недостаток - может потратить слишком много ресурсов в лабиринтах, где помимо коридоров есть залы. Потому что каждая клетка зала это перекрёсток из 4х дорожек. На каждом перекрёстке алгоритм последовательно постарается перебрать все варианты движений, наивно полагая, что на сей раз повезёт, и тупика не будет. Таким образом, в итоге будут перебраны ВСЕ возможные варианты пересечения зала: прямо, по змейке, вдль стены... масштабы подобного перебора ужасают.
- создана анимация работы алгоритма

## АЛГОРИТМ ВОЛНОВОЙ ТРАССИРОВКИ
Моделирует поведение  разлитой в лабиринте воды.
Достоинства:
- простой
- отлично справляется с залами и находит оптимальное решение очень быстро
Недостатки:
- большой расход памяти
- создана анимация работы алгоритма

# АЛГОРИТМЫ ПОСТРОЕНИЯ ЛАБИРИНТОВ
Лабиринты, сгенерированные нижеприведёнными алгоритмами не содержат залов и из любой локации лабиринта можно попасть в любую другую, то есть не существует замкнутых областей, отделённых от остальных частей лабиринта.

## АЛГОРИТМ ПРИМА
- анимация построения всё скажет за этот алгоритм

## АЛГОРИТМ КРАСКАЛА
- заводится список стен, выбирается рандомная из списка и сносится, если локации, к ней прилегающие не хода друг к другу

## TODO
- Два простых способа улучщить алгоритм волновой трассировки:
   - На каждой итерации работы алгоритма происходит поиск локаций, помеченных числом N. Чтобы не пробегать по всему лабиринту, можно просто хранить их в отдельном списке (разумеется, его придётся постоянно обновлять)
   - Можно "разлить кисель" не только в стартовой локации, но и в финишной. Как только оба потока жидкости пересекутся в некоторой локации, маршрут найден.
- Подумайте, как можно реализовать алгоритм Прима более эффективно. К примеру, храните все Border-локации в отдельном списке, чтобы не просматривать в их поиске весь лабиринт на каждой итерации.
